<!DOCTYPE html>
<html lang="tr">
<head>
  <meta charset="UTF-8" />
  <title>cooja-positioner — OSM (Leaflet) Map Only</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!-- Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin=""/>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
  <style>
    html, body { margin: 0; height: 100%; overflow: hidden; font-family: Arial, sans-serif; }
    #container { display: flex; height: 100%; }
    #stage { position: relative; flex: 1; overflow: hidden; }
    #map { position: absolute; inset: 0; z-index: 0; }
    canvas#grid { position: absolute; inset: 0; z-index: 1; pointer-events: none; }

    #sidebar { width: 340px; padding: 10px; background: #fff; border-left: 1px solid #ccc; display: flex; flex-direction: column; gap: 10px; }
    #controls label { display: inline-block; width: 110px; }
    #controls input, #controls select { width: 200px; }
    #output { flex: 1; overflow-y: auto; font-family: monospace; white-space: pre; border: 1px solid #ccc; padding: 5px; }
    .hint { font-size: 12px; color: #555; line-height: 1.4; }
    .btnrow { display: flex; gap: 8px; flex-wrap: wrap; }
    button { padding: 6px 10px; }
  </style>
</head>
<body>
  <div id="container">
    <div id="stage">
      <div id="map" aria-label="OpenStreetMap"></div>
      <canvas id="grid"></canvas>
    </div>

    <div id="sidebar">
      <div id="searchContainer">
        <label for="searchInput"><b>Konum Ara</b></label>
        <div style="position: relative;">
          <input type="text" id="searchInput" placeholder="Şehir, adres veya yer adı girin..." style="width: 100%; padding: 8px; margin-bottom: 5px;">
          <div id="searchResults" style="position: absolute; top: 100%; left: 0; right: 0; background: white; border: 1px solid #ccc; border-top: none; max-height: 200px; overflow-y: auto; z-index: 1000; display: none;"></div>
        </div>
      </div>

      <div class="mode" style="display:flex; gap:10px; align-items:center;">
        <label for="modeSelect"><b>Çalışma Modu</b></label>
        <select id="modeSelect" style="flex: 1;">
          <option value="maps" selected>Harita Modu (Maps Mode)</option>
          <option value="point">Nokta Ekleme (Point Add)</option>
        </select>
      </div>

      <div id="controls">
        <label for="nodeIdInput">Node ID:</label>
        <input type="number" id="nodeIdInput" value="1"><br><br>
        <label for="intervalInput">Interval (ms):</label>
        <input type="number" id="intervalInput" value="1000"><br><br>
        <label for="exportSelect">Çıktı:</label>
        <select id="exportSelect">
          <option value="xy" selected>positions.dat (x y)</option>
          <option value="latlng">positions.dat (lat lon)</option>
        </select>
      </div>
      <div class="btnrow">
        <button id="undoBtn" title="Ctrl+Z">Undo</button>
        <button id="redoBtn" title="Ctrl+Y veya Ctrl+Shift+Z">Redo</button>
        <button id="deleteBtn" title="Del / Backspace">Seçileni Sil</button>
        <button id="resetBtn">Reset</button>
        <button id="saveBtn">Save positions.dat</button>
        <input type="file" id="uploadInput" accept=".dat" />
      </div>
      <div class="hint">
        <b>İpuçları</b><br/>
        <b>Harita Modu:</b> Adres arama, haritayı sürükleme, zoom in/out yapabilirsiniz.<br/>
        <b>Nokta Ekleme Modu:</b> Harita görünümü sabit kalır. Sol tık ile nokta ekle, noktaları sürükleyerek düzenle. Çoklu seçim için boş alanda sürükleyip kutu çiz.<br/>
        Kısayollar: Ctrl/Cmd+A (tümünü seç), Del (sil), Ctrl+Z / Ctrl+Y (undo/redo).
      </div>
      <div>
        <label for="latlngInput"><b>Enlem/Boylam Girişi</b></label>
        <textarea id="latlngInput" placeholder="&lt;node_id&gt; &lt;time&gt; &lt;latitude&gt; &lt;longitude&gt;&#10;Örnek:&#10;1 0.0 41.2867 36.33&#10;1 1.0 41.2870 36.331" style="width: 100%; height: 150px; font-family: monospace; font-size: 12px; padding: 5px; border: 1px solid #ccc; resize: vertical;"></textarea>
        <button id="convertBtn" style="margin-top: 5px; padding: 6px 10px;">Dönüştür</button>
      </div>
      <div>
        <label for="output"><b>positions.dat</b></label>
        <pre id="output"></pre>
      </div>
    </div>
  </div>

  <script>
    // === DOM ===
    const stage = document.getElementById('stage');
    const canvas = document.getElementById('grid');
    const ctx = canvas.getContext('2d');
    const output = document.getElementById('output');
    const nodeInput = document.getElementById('nodeIdInput');
    const intervalInput = document.getElementById('intervalInput');
    const uploadInput = document.getElementById('uploadInput');
    const resetBtn = document.getElementById('resetBtn');
    const saveBtn = document.getElementById('saveBtn');
    const deleteBtn = document.getElementById('deleteBtn');
    const undoBtn = document.getElementById('undoBtn');
    const redoBtn = document.getElementById('redoBtn');
    const exportSelect = document.getElementById('exportSelect');
    const searchInput = document.getElementById('searchInput');
    const searchResults = document.getElementById('searchResults');
    const latlngInput = document.getElementById('latlngInput');
    const convertBtn = document.getElementById('convertBtn');
    const modeSelect = document.getElementById('modeSelect');

    // === Leaflet Map ===
    const map = L.map('map', {
      center: [41.2867, 36.33], // Samsun near OMU as a sensible default
      zoom: 15,
      zoomControl: true,
      attributionControl: true
    });
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      maxZoom: 19,
      attribution: '&copy; OpenStreetMap contributors'
    }).addTo(map);

    // === Styles ===
    const NODE_STYLE = {
      fill: 'rgba(0, 122, 255, 0.25)',
      stroke: 'rgba(0, 92, 205, 0.90)',
      strokeWidth: 1.25,
      label: '#111'
    };
    const SELECTED_STYLE = { stroke: 'rgba(255,165,0,0.95)', lineWidth: 2.2 };

    // === State ===
    let mode = 'maps'; // 'maps' | 'point'
    let positions = []; // items: { lat, lng }
    let selected = new Set();
    let isSelectingRect = false; let selStartS=null, selEndS=null;
    let draggingNodeIndex = -1; let selectedInitial = null; let preDragSnapshot = null; let dragStartPx = null;
    let wasDragging = false;

    // Undo/Redo
    const undoStack = []; const redoStack = [];
    const snapshot = () => JSON.parse(JSON.stringify({ positions }));
    function commitHistory(){ undoStack.push(snapshot()); if (undoStack.length>200) undoStack.shift(); redoStack.length=0; }
    function restore(state){ positions = JSON.parse(JSON.stringify(state.positions)); draw(); updateOutput(); }

    // Utils
    function resize() {
      const rect = stage.getBoundingClientRect();
      canvas.width = rect.width; canvas.height = rect.height;
      draw();
    }
    window.addEventListener('resize', resize); resize();

    function nodeRadiusPx(){ return Math.max(3, 5); }

    function fitFontToCircle(text, radiusPx, minPx = 8) {
      const maxDiameter = radiusPx * 2 * 0.9; let lo=minPx, hi=Math.max(minPx, Math.floor(radiusPx*1.8)), best=lo;
      while (lo<=hi){ const mid=(lo+hi>>1); ctx.font=`bold ${mid}px Arial`; const m=ctx.measureText(text); const h=(m.actualBoundingBoxAscent||mid*.8)+(m.actualBoundingBoxDescent||mid*.2); const w=m.width; if (w<=maxDiameter && h<=maxDiameter){ best=mid; lo=mid+1;} else hi=mid-1; }
      return best;
    }

    function hitTestNodeMap(px, py){ const r = nodeRadiusPx();
      for (let i=positions.length-1;i>=0;--i){ const p=positions[i]; const pt = map.latLngToContainerPoint([p.lat, p.lng]); const dx=pt.x-px, dy=pt.y-py; if (Math.hypot(dx,dy)<=r) return i; }
      return -1; }

    // === Mode Selection ===
    modeSelect.addEventListener('change', () => {
      mode = modeSelect.value;
      if (mode === 'maps') {
        // Maps mode: Enable map dragging and zooming
        map.dragging.enable();
        map.touchZoom.enable();
        map.doubleClickZoom.enable();
        map.scrollWheelZoom.enable();
        map.boxZoom.enable();
        map.keyboard.enable();
      } else if (mode === 'point') {
        // Point mode: Disable map dragging and zooming
        map.dragging.disable();
        map.touchZoom.disable();
        map.doubleClickZoom.disable();
        map.scrollWheelZoom.disable();
        map.boxZoom.disable();
        map.keyboard.disable();
      }
      draw();
    });

    // Initialize mode
    modeSelect.dispatchEvent(new Event('change'));

    // === Map-mode interactions ===
    map.on('mousemove', (e)=>{ 
      // Only allow node dragging in point mode
      if (mode === 'point' && draggingNodeIndex>=0 && selected.size>0){ 
        wasDragging = true;
        const currentLatLng = e.latlng;
        const startLatLng = [preDragSnapshot.positions[draggingNodeIndex].lat, preDragSnapshot.positions[draggingNodeIndex].lng];
        const latOffset = currentLatLng.lat - startLatLng[0];
        const lngOffset = currentLatLng.lng - startLatLng[1];
        for (const si of selectedInitial) {
          positions[si.idx].lat = si.lat + latOffset;
          positions[si.idx].lng = si.lng + lngOffset;
        }
        draw();
      }
    });

    map.on('mousedown', (e)=>{ 
      // Only allow node editing in point mode
      if (mode === 'point') {
        const pt = map.latLngToContainerPoint(e.latlng); const i = hitTestNodeMap(pt.x, pt.y);
        if (i>=0){ 
          selected.clear(); 
          selected.add(i); 
          draggingNodeIndex=i; 
          preDragSnapshot=snapshot(); 
          selectedInitial=Array.from(selected).map(idx=>({ idx, lat:positions[idx].lat, lng:positions[idx].lng })); 
          dragStartPx = map.latLngToContainerPoint([positions[i].lat, positions[i].lng]);
          wasDragging = false;
          map.dragging.disable();
        }
        else {
          isSelectingRect=true; selStartS={ x: pt.x, y: pt.y }; selEndS={ x: pt.x, y: pt.y };
          window.mouseDownLatLng = e.latlng;
        }
      }
    });

    map.on('mouseup', (e)=>{ 
      if (draggingNodeIndex>=0){ 
        const before=JSON.stringify(preDragSnapshot.positions); 
        const after=JSON.stringify(positions); 
        if (before !== after) commitHistory(); 
      }
      else if (isSelectingRect && window.mouseDownLatLng && mode === 'point') {
        // Only allow point addition in point mode
        const dx=Math.abs(selEndS.x-selStartS.x), dy=Math.abs(selEndS.y-selStartS.y); 
        const dragged=(dx+dy)>4; 
        if (!dragged) {
          commitHistory(); 
          const lat = window.mouseDownLatLng.lat;
          const lng = window.mouseDownLatLng.lng;
          positions.push({ lat, lng }); 
          selected.clear(); 
          selected.add(positions.length-1); 
          
          const nodeId = parseInt(nodeInput.value) || 1;
          const intervalMs = parseFloat(intervalInput.value) || 1000;
          const time = ((positions.length - 1) * intervalMs / 1000).toFixed(9);
          
          const latStr = lat.toFixed(9);
          const lngStr = lng.toFixed(9);
          const newLine = `${nodeId} ${time} ${latStr} ${lngStr}`;
          
          if (latlngInput.value.trim()) {
            latlngInput.value += '\n' + newLine;
          } else {
            latlngInput.value = newLine;
          }
          
          // Scroll to bottom
          latlngInput.scrollTop = latlngInput.scrollHeight;
          
          draw(); 
        } else {
          const minX=Math.min(selStartS.x, selEndS.x), maxX=Math.max(selStartS.x, selEndS.x); 
          const minY=Math.min(selStartS.y, selEndS.y), maxY=Math.max(selStartS.y, selEndS.y); 
          selected.clear(); 
          positions.forEach((p,idx)=>{ 
            const s = map.latLngToContainerPoint([p.lat,p.lng]); 
            if (s.x>=minX && s.x<=maxX && s.y>=minY && s.y<=maxY) selected.add(idx); 
          }); 
        }
      }
      
      // Re-enable dragging only in maps mode
      if (mode === 'maps') {
        map.dragging.enable();
      }
      draggingNodeIndex=-1; selectedInitial=null; preDragSnapshot=null; 
      isSelectingRect=false; selStartS=selEndS=null; 
      window.mouseDownLatLng = null;
      setTimeout(() => { wasDragging = false; }, 50);
      draw(); 
    });

    map.on('move zoom', ()=>{ 
      requestAnimationFrame(() => {
        draw();
      });
    });
    
    map.on('zoomend', ()=>{ 
      draw();
    });

    // Add Ctrl+mouse wheel zoom functionality (only in maps mode)
    map.getContainer().addEventListener('wheel', (e) => {
      if (mode === 'maps' && e.ctrlKey) {
        e.preventDefault();
        const rect = map.getContainer().getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;
        const mouseLatLng = map.containerPointToLatLng([mouseX, mouseY]);
        const zoomIn = e.deltaY < 0;
        const currentZoom = map.getZoom();
        const newZoom = zoomIn ? currentZoom + 1 : currentZoom - 1;
        const clampedZoom = Math.max(1, Math.min(19, newZoom));
        map.setView(mouseLatLng, clampedZoom);
      }
    }, { passive: false });

    // Keyboard
    window.addEventListener('keydown', (e)=>{
      if ((e.key === 'Backspace' || e.key === 'Delete')) { e.preventDefault(); deleteSelected(); }
      if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase()==='a'){ e.preventDefault(); selected = new Set(positions.map((_,idx)=>idx)); draw(); }
      if ((e.ctrlKey || e.metaKey) && !e.shiftKey && e.key.toLowerCase()==='z'){ e.preventDefault(); undo(); }
      else if ((e.ctrlKey || e.metaKey) && (e.key.toLowerCase()==='y' || (e.shiftKey && e.key.toLowerCase()==='z'))){ e.preventDefault(); redo(); }
    });

    function undo(){ if (!undoStack.length) return; const curr=snapshot(); const prev=undoStack.pop(); redoStack.push(curr); restore(prev); }
    function redo(){ if (!redoStack.length) return; const curr=snapshot(); const next=redoStack.pop(); undoStack.push(curr); restore(next); }

    function deleteSelected(){ if (!selected.size) return; commitHistory(); positions = positions.filter((_,idx)=>!selected.has(idx)); selected.clear(); draw(); updateOutput(); }

    resetBtn.addEventListener('click', ()=>{ commitHistory(); positions = []; selected.clear(); updateOutput(); draw(); });
    saveBtn.addEventListener('click', ()=>{ const blob = new Blob([output.textContent], { type: 'text/plain' }); const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='positions.dat'; a.click(); });

    uploadInput.addEventListener('change', (e)=>{ const file=e.target.files[0]; if (!file) return; const reader=new FileReader(); reader.onload=(evt)=>{
        commitHistory(); const lines = evt.target.result.split(/\r?\n/); positions=[]; 
        for (const line of lines){ if (!line.trim()) continue; const parts=line.trim().split(/\s+/); if (parts.length<4) continue; 
          const x=parseFloat(parts[2]); const y=parseFloat(parts[3]); 
          if (exportSelect.value==='latlng'){ positions.push({ lat:x, lng:y }); } else {
            const center = map.getCenter(); const centerPt = map.project(center, map.getZoom()); 
            const metersPerPixel = calcMetersPerPixel(center.lat, map.getZoom()); 
            const dx = x / metersPerPixel; const dy = -y / metersPerPixel; 
            const targetPt = L.point(centerPt.x + dx, centerPt.y + dy); 
            const ll = map.unproject(targetPt, map.getZoom()); 
            positions.push({ lat: ll.lat, lng: ll.lng }); }
        }
        selected.clear(); updateOutput(); draw(); };
      reader.readAsText(file);
    });

    function calcMetersPerPixel(lat, zoom){ const earthCircumference = 40075016.686; return Math.cos(lat*Math.PI/180) * earthCircumference / Math.pow(2, zoom+8); }

    function draw(){
      const rect = stage.getBoundingClientRect();
      if (canvas.width !== rect.width || canvas.height !== rect.height) {
        canvas.width = rect.width;
        canvas.height = rect.height;
      }
      ctx.clearRect(0,0,canvas.width, canvas.height);

      const rPx = nodeRadiusPx(); let index=1; 
      if (positions.length>1){ 
        ctx.beginPath(); ctx.strokeStyle='blue'; ctx.lineWidth=1.5; 
        let s = map.latLngToContainerPoint([positions[0].lat, positions[0].lng]); 
        ctx.moveTo(s.x, s.y); 
        for (let i=1;i<positions.length;i++){ 
          s = map.latLngToContainerPoint([positions[i].lat, positions[i].lng]); 
          ctx.lineTo(s.x, s.y);
        } 
        ctx.stroke(); 
      }
      for (let i=0;i<positions.length;i++){ 
        const p=positions[i]; 
        const s=map.latLngToContainerPoint([p.lat, p.lng]); 
        drawNodeCircle(s.x, s.y, rPx, i+1); 
      }
      if (isSelectingRect && selStartS && selEndS){ drawSelectionRect(selStartS.x, selStartS.y, selEndS.x, selEndS.y); }
    }

    function drawNodeCircle(cx, cy, rPx, index){ 
      ctx.beginPath(); ctx.fillStyle=NODE_STYLE.fill; ctx.strokeStyle=NODE_STYLE.stroke; ctx.lineWidth=NODE_STYLE.strokeWidth; 
      ctx.arc(cx, cy, rPx, 0, Math.PI*2); ctx.fill(); ctx.stroke();
      const idx=index-1; if (selected.has(idx)){ 
        ctx.beginPath(); ctx.strokeStyle=SELECTED_STYLE.stroke; ctx.lineWidth=SELECTED_STYLE.lineWidth; 
        ctx.arc(cx, cy, rPx+2, 0, Math.PI*2); ctx.stroke(); 
      }
      const label=String(index); const fontSize=fitFontToCircle(label, rPx, 8); 
      ctx.font=`bold ${fontSize}px Arial`; ctx.fillStyle=NODE_STYLE.label; ctx.textAlign='center'; ctx.textBaseline='middle'; 
      ctx.fillText(label, cx, cy); 
    }

    function drawSelectionRect(x1,y1,x2,y2){ 
      const x=Math.min(x1,x2), y=Math.min(y1,y2), w=Math.abs(x2-x1), h=Math.abs(y2-y1); 
      ctx.save(); ctx.fillStyle='rgba(0,120,215,0.15)'; ctx.strokeStyle='rgba(0,120,215,0.9)'; ctx.lineWidth=1.2; 
      ctx.fillRect(x,y,w,h); ctx.strokeRect(x,y,w,h); ctx.restore(); 
    }

    function updateOutput(){
      const nodeId = parseInt(nodeInput.value)||1; const intervalMs=parseFloat(intervalInput.value)||1000;
      const lines = positions.map((p,i)=>{
        const timeStr = (i*intervalMs/1000).toFixed(9);
        if (exportSelect.value==='latlng'){
          const latStr = p.lat.toFixed(9); const lngStr = p.lng.toFixed(9);
          return `${nodeId} ${timeStr} ${latStr} ${lngStr} 0.000000000 0.000000000`;
        } else {
          const center = map.getCenter(); const centerPt = map.project(center, map.getZoom()); 
          const pt = map.project([p.lat,p.lng], map.getZoom()); 
          const metersPerPixel = calcMetersPerPixel(center.lat, map.getZoom()); 
          const dx = (pt.x - centerPt.x) * metersPerPixel; 
          const dy = -(pt.y - centerPt.y) * metersPerPixel;
          return `${nodeId} ${timeStr} ${dx.toFixed(9)} ${dy.toFixed(9)} 0.000000000 0.000000000`;
        }
      });
      output.textContent = lines.join('\n');
    }

    exportSelect.addEventListener('change', updateOutput);

    convertBtn.addEventListener('click', () => {
      output.textContent = latlngInput.value;
    });

    latlngInput.addEventListener('input', (e) => {
      const text = e.target.value.trim();
      if (!text) return;
      const lines = text.split(/\r?\n/);
      const newPositions = [];
      for (const line of lines) {
        if (!line.trim()) continue;
        const parts = line.trim().split(/\s+/);
        if (parts.length < 4) continue;
        const lat = parseFloat(parts[2]);
        const lng = parseFloat(parts[3]);
        if (isNaN(lat) || isNaN(lng) || lat < -90 || lat > 90 || lng < -180 || lng > 180) continue;
        newPositions.push({ lat, lng });
      }
      if (newPositions.length > 0) {
        commitHistory();
        positions = newPositions;
        selected.clear();
        draw();
        updateOutput();
      }
    });

    // === Search Functionality ===
    let searchTimeout;
    let currentSearchResults = [];

    searchInput.addEventListener('input', (e) => {
      const query = e.target.value.trim();
      if (searchTimeout) clearTimeout(searchTimeout);
      if (query.length === 0) { searchResults.style.display = 'none'; return; }
      searchTimeout = setTimeout(() => { searchLocation(query); }, 300);
    });

    document.addEventListener('click', (e) => {
      if (!searchInput.contains(e.target) && !searchResults.contains(e.target)) {
        searchResults.style.display = 'none';
      }
    });

    async function searchLocation(query) {
      try {
        const response = await fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(query)}&limit=5&addressdetails=1&countrycodes=tr`);
        const results = await response.json();
        currentSearchResults = results;
        displaySearchResults(results);
      } catch (error) {
        console.error('Search error:', error);
        searchResults.innerHTML = '<div style="padding: 10px; color: red;">Arama sırasında hata oluştu</div>';
        searchResults.style.display = 'block';
      }
    }

    function displaySearchResults(results) {
      if (results.length === 0) {
        searchResults.innerHTML = '<div style="padding: 10px; color: #666;">Sonuç bulunamadı</div>';
        searchResults.style.display = 'block';
        return;
      }
      searchResults.innerHTML = results.map((result, index) => {
        const displayName = result.display_name.split(',').slice(0, 3).join(',');
        return `<div class="search-result-item" data-index="${index}" style="padding: 8px; cursor: pointer; border-bottom: 1px solid #eee; font-size: 13px;">
          <div style="font-weight: bold;">${result.display_name.split(',')[0]}</div>
          <div style="color: #666; font-size: 11px;">${displayName}</div>
        </div>`;
      }).join('');
      searchResults.querySelectorAll('.search-result-item').forEach(item => {
        item.addEventListener('click', () => {
          const index = parseInt(item.dataset.index);
          selectSearchResult(index);
        });
        item.addEventListener('mouseenter', () => { item.style.backgroundColor = '#f0f0f0'; });
        item.addEventListener('mouseleave', () => { item.style.backgroundColor = 'white'; });
      });
      searchResults.style.display = 'block';
    }

    function selectSearchResult(index) {
      const result = currentSearchResults[index];
      if (result) {
        const lat = parseFloat(result.lat);
        const lng = parseFloat(result.lon);
        map.setView([lat, lng], 15);
        searchInput.value = result.display_name.split(',')[0];
        searchResults.style.display = 'none';
      }
    }

    // initial draw
    draw(); updateOutput();
  </script>
</body>
</html>

